<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Uspf (uspf.Uspf)</title><link rel="stylesheet" href="../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">uspf</a> &#x00BB; Uspf</nav><header class="odoc-preamble"><h1>Module <code><span>Uspf</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#(un)sender-policy-framework.">(Un)Sender Policy Framework.</a><ul><li><a href="#how-to-use-uspf.">How to use uSPF.</a></li><li><a href="#reproductibility.">Reproductibility.</a></li><li><a href="#as-a-server.">As a server.</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="(un)sender-policy-framework."><a href="#(un)sender-policy-framework." class="anchor"></a>(Un)Sender Policy Framework.</h2><p>uSPF is a framework to check the identity of the email's sender. When an email passes through an SMTP server, some informations are available such as the source of the email, the IP address (because the sender must initiate a TCP/IP connexion).</p><p>From these informations and via uSPF (and DNS records), we are able to <i>authorize</i> the given email or not. Indeed, the email submission process requires an identity with the SMTP <code>MAILFROM</code> command. At this stage, we are able to check if the domain name given by <code>MAILFROM</code> and the current IP address of the sender match!</p><p>The domain-name used by <code>MAILFROM</code> should have some DNS records which describe which IP address is allowed to send an email via the <code>MAILFROM</code>'s identity. uSPF will check that and it will try to find a <i>match</i>. In any results - if uSPF fails or not - the SMTP server will put the result of such check into the given email.</p><p>Finally, it permits to check, at any step of the submission, the identity of the sender. However, it does not ensure a high level of securities when uSPF should be use with DKIM/DMARC to ensure some others aspects such as the integrity of the given email.</p><h3 id="how-to-use-uspf."><a href="#how-to-use-uspf." class="anchor"></a>How to use uSPF.</h3><p>uSPF requires some <i>meta</i> informations such as the <code>MAILFROM</code> identity and the IP address of the sender. The user can create a <a href="#type-ctx"><code>ctx</code></a> and fill it with these information:</p><pre class="language-ocaml"><code>let ctx =
  Uspf.empty |&gt; Uspf.with_sender (`MAILFROM path) |&gt; Uspf.with_ip ipaddr</code></pre><p>From this <code>ctx</code>, then the user is able to <i>check</i> the identity of the sender via a DNS implementation. The user must get the SPF DNS record, analyze it and use it then with the <code>ctx</code>:</p><pre class="language-ocaml"><code>let res =
  Uspf.get ctx sched dns (module DNS)
  &gt;&gt;= Uspf.check ctx sched dns (module DNS)</code></pre><p>From the result, the user is able to generate an <i>header field</i>. It optional to give your identity (your domain) to be exhaustive about <i>meta</i> information on the field value:</p><pre class="language-ocaml"><code>let field_name, value = Uspf.to_field ~ctx ?receiver res</code></pre><p>The value is well-formed for the incoming email. You just need to prepend the field before the email.</p><h3 id="reproductibility."><a href="#reproductibility." class="anchor"></a>Reproductibility.</h3><p>The API provides a possibility to extract SPF results from an incoming email and regenerate the <code>ctx</code> from them. By this way, locally, you can reproduce the process above. By this way, you are able to reproduce the written result and check if it still is valid.</p><p>Indeed, due to the DNS record requirement to check the identity of the sender, it possible that <i>meta</i> informations from the given email are obsoletes (for any reasons).</p><h3 id="as-a-server."><a href="#as-a-server." class="anchor"></a>As a server.</h3><p>uSPF allows the end-user to craft its own record and publish it then into its primary/secondary DNS server. Multiple values exists such as:</p><ul><li><a href="#val-a"><code>a</code></a></li><li><a href="#val-mx"><code>mx</code></a></li><li><a href="#val-all"><code>all</code></a></li><li><a href="#val-pass"><code>pass</code></a></li><li>or <a href="#val-fail"><code>fail</code></a></li></ul><p>They permits to describe <i>via</i> OCaml the SPF record. It can be serialized to a simple <code>string</code> then and the user can save it into its own primary/secondary DNS server.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Sigs"><a href="#module-Sigs" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sigs/index.html">Sigs</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ctx"><a href="#type-ctx" class="anchor"></a><code><span><span class="keyword">type</span> ctx</span></code></div><div class="spec-doc"><p>The type for contexts. It's a <i>heterogeneous map</i> of values to help uSPF to validate the sender. It requires the <code>MAILFROM</code> parameter given by the SMTP protocol (which can be filled <i>via</i> <a href="#val-with_sender"><code>with_sender</code></a>) and/or the IP address of the sender (which can be filled <i>via</i> <a href="#val-with_ip"><code>with_ip</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-ctx">ctx</a></span></code></div><div class="spec-doc"><p><code>empty</code> is an empty context.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_sender"><a href="#val-with_sender" class="anchor"></a><code><span><span class="keyword">val</span> with_sender : 
  <span><span>[ <span>`HELO of <span><span>[ `raw ]</span> <span class="xref-unresolved">Domain_name</span>.t</span></span> <span><span>| `MAILFROM</span> of <span class="xref-unresolved">Colombe</span>.Path.t</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-ctx">ctx</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ctx">ctx</a></span></code></div><div class="spec-doc"><p><code>with_sender v ctx</code> adds into the given <code>ctx</code> the sender of the incoming email (its simple domain name or the complete email address).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_ip"><a href="#val-with_ip" class="anchor"></a><code><span><span class="keyword">val</span> with_ip : <span><span class="xref-unresolved">Ipaddr</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ctx">ctx</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ctx">ctx</a></span></code></div><div class="spec-doc"><p><code>with_ip v ctx</code> adds into the given <code>ctx</code> the IP address of the sender.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-domain"><a href="#val-domain" class="anchor"></a><code><span><span class="keyword">val</span> domain : <span><a href="#type-ctx">ctx</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>[ `raw ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> option</span></span></code></div><div class="spec-doc"><p><code>domain ctx</code> returns the domain-name of the sender if it exists.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Macro"><a href="#module-Macro" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Macro/index.html">Macro</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Term"><a href="#module-Term" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Term/index.html">Term</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-record"><a href="#type-record" class="anchor"></a><code><span><span class="keyword">type</span> record</span></code></div><div class="spec-doc"><p>The type of SPF records.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-mechanism"><a href="#type-mechanism" class="anchor"></a><code><span><span class="keyword">type</span> mechanism</span></code></div><div class="spec-doc"><p>The type of mechanisms.</p><p>A mechanism permits to design and identify a set of IP addresses as being permitted or not permitted to use the <a href="#val-domain"><code>domain</code></a> for sending mail.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-a"><a href="#val-a" class="anchor"></a><code><span><span class="keyword">val</span> a : <span>?cidr_v4:int <span class="arrow">&#45;&gt;</span></span> <span>?cidr_v6:int <span class="arrow">&#45;&gt;</span></span> <span><span><span>[ `raw ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p>This mechanism matches if the sender's IP address is one of the domain-name's IP addresses. For clarity, this means the <code>a</code> mechanism also matches <code>AAAA</code> records.</p><p>An address lookup is done on the domain-name using the type of lookup (A or AAAA) appropriate for the connection type. The IP is compared to the returned address(es). If any address matches, the mechanism matches.</p><p>A <i>Classless Inter-Domain Routing</i> can be applied to returned address(es) (IPv4 or IPv6) to compare with the sender's IP address. For instance, <code>a=10.0.0.42/32</code> matches only <code>10.0.0.42</code> as the sender's IP address but <code>a=10.0.0.42/24</code> matches any <code>10.0.0.*</code> addresses. By default, <code>cidr_v4 = 32</code> and <code>cidr_v6 = 128</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p>The <code>all</code> mechanism is a test that always matches. It is used as the rightmost mechanism (the last mechanism) in a record to provide an explicit default. For example <code>v=spf1 a mx -all</code>.</p><p>Mechanisms after <code>all</code> will never be tested.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span><span>[ `raw ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p>This mechanism is used to construct an arbitrary domain name that is used for a DNS A record query. It allows for complicated schemes involving arbitrary parts on the mail envelope to determine what is permitted.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inc"><a href="#val-inc" class="anchor"></a><code><span><span class="keyword">val</span> inc : <span><span><span>[ `raw ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p>The <code>include</code> mechanism triggers a <i>recursive</i> evaluation of <a href="#val-check"><code>check</code></a>:</p><ol><li>The macro is expanded according to the given <code>ctx</code></li><li>We re-execute <a href="#val-check"><code>check</code></a> with the produced domain-name (IP and sender arguments remain the same)</li><li>The recursive evaluation returns <i>match</i>, <i>not-match</i> or an error.</li><li>If it returns <i>match</i>, then the appropriate result for the <code>include</code> mechanism is used (see <a href="#type-qualifier"><code>qualifier</code></a>)</li><li>It it returns <i>not-match</i> or an error, the <a href="#val-check"><code>check</code></a> process tests the next mechanism.</li></ol><p><b>Note</b>: for instance, if the domain-name has <code>-all</code>, <code>include</code> does not strictly terminates the processus. It fails and let <a href="#val-check"><code>check</code></a> to process the next mechanism.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mx"><a href="#val-mx" class="anchor"></a><code><span><span class="keyword">val</span> mx : <span>?cidr_v4:int <span class="arrow">&#45;&gt;</span></span> <span>?cidr_v6:int <span class="arrow">&#45;&gt;</span></span> <span><span><span>[ `raw ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p>This mechanims matches if the sender's IP is one of the MX hosts for a domain-name. A domain-name should have a MX record which is an IP address. If this IP address is the same as the given IP address into the given <a href="#type-ctx"><code>ctx</code></a>, we consider that the sender <i>matches</i>.</p><p><b>Note</b>: if the domain-name has no MX record, <a href="#val-check"><code>check</code></a> does not apply the implicit MX rules by querying for an A or AAAA record for the same name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-v4"><a href="#val-v4" class="anchor"></a><code><span><span class="keyword">val</span> v4 : <span><span class="xref-unresolved">Ipaddr</span>.V4.Prefix.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p>This mechanism test whether the given IP from the given <a href="#type-ctx"><code>ctx</code></a> is contained within a given IPv4 network.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-v6"><a href="#val-v6" class="anchor"></a><code><span><span class="keyword">val</span> v6 : <span><span class="xref-unresolved">Ipaddr</span>.V6.Prefix.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p>This mechanism test whether the given IP from the given <a href="#type-ctx"><code>ctx</code></a> is contained within a given IPv: network.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-modifier"><a href="#type-modifier" class="anchor"></a><code><span><span class="keyword">type</span> modifier</span></code></div><div class="spec-doc"><p>The type of modifiers.</p><p>They are not available because they mostly provide additional information which are not needed for <a href="#val-check"><code>check</code></a>. By this way, it's not needed to let the user to define some when they are not effective on the user's sender policy.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-qualifier"><a href="#type-qualifier" class="anchor"></a><code><span><span class="keyword">type</span> qualifier</span><span> = </span></code><ol><li id="type-qualifier.Pass" class="def variant constructor anchored"><a href="#type-qualifier.Pass" class="anchor"></a><code><span>| </span><span><span class="constructor">Pass</span></span></code></li><li id="type-qualifier.Fail" class="def variant constructor anchored"><a href="#type-qualifier.Fail" class="anchor"></a><code><span>| </span><span><span class="constructor">Fail</span></span></code></li><li id="type-qualifier.Softfail" class="def variant constructor anchored"><a href="#type-qualifier.Softfail" class="anchor"></a><code><span>| </span><span><span class="constructor">Softfail</span></span></code></li><li id="type-qualifier.Neutral" class="def variant constructor anchored"><a href="#type-qualifier.Neutral" class="anchor"></a><code><span>| </span><span><span class="constructor">Neutral</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The type of qualifiers.</p><p>A qualifier specifies what the mechanism returns when it matches or not:</p><ul><li><code>+</code> returns <code>pass</code> if the mechanism matches</li><li><code>-</code> returns <code>fail</code> if the mechanism matches</li><li><code>~</code> returns <code>softfail</code> if the mechanism matches</li><li><code>?</code> returns <code>neutral</code> if the mechanism matches</li></ul><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pass"><a href="#val-pass" class="anchor"></a><code><span><span class="keyword">val</span> pass : <span><a href="#type-mechanism">mechanism</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-qualifier">qualifier</a> * <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p><code>pass m</code> specifies the <a href="#type-qualifier"><code>qualifier</code></a> of the given mechanism <code>m</code>. If the mechanism <i>matches</i> from the given <a href="#type-ctx"><code>ctx</code></a>, <a href="#val-check"><code>check</code></a> returns <code>`Pass</code>. Otherwise, <a href="#val-check"><code>check</code></a> tries the next mechanism.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span><a href="#type-mechanism">mechanism</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-qualifier">qualifier</a> * <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p><code>fail m</code> specifies the <a href="#type-qualifier"><code>qualifier</code></a> of the given mechanism <code>m</code>. If the mechanism <i>matches</i> from the given <a href="#type-ctx"><code>ctx</code></a>, <a href="#val-check"><code>check</code></a> tries the next mechanism (as it considers the current one as a failure). If the mechanism is the last one, <a href="#val-check"><code>check</code></a> returns <code>`Fail</code> so.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-softfail"><a href="#val-softfail" class="anchor"></a><code><span><span class="keyword">val</span> softfail : <span><a href="#type-mechanism">mechanism</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-qualifier">qualifier</a> * <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p><code>softfail m</code> specifies the <a href="#type-qualifier"><code>qualifier</code></a> of the given mechanism <code>m</code>. If the mechanism <i>matches</i> from the given <a href="#type-ctx"><code>ctx</code></a>, <a href="#val-check"><code>check</code></a> tries the next mechanism (as it considers the current one as a <i>soft</i> failure). If the mechanism is the last one, <a href="#val-check"><code>check</code></a> returns <code>`Softfail</code> so.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-neutral"><a href="#val-neutral" class="anchor"></a><code><span><span class="keyword">val</span> neutral : <span><a href="#type-mechanism">mechanism</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-qualifier">qualifier</a> * <a href="#type-mechanism">mechanism</a></span></code></div><div class="spec-doc"><p><code>neutral m</code> specifies the <a href="#type-qualifier"><code>qualifier</code></a> of the given mechanism <code>m</code>. Regardless the result of the mechanism (if it matches or not), <a href="#val-check"><code>check</code></a> tries the next mechanism. If the mechanism is the last one, <a href="#val-check"><code>check</code></a> returns <code>`Neutral</code> so.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record"><a href="#val-record" class="anchor"></a><code><span><span class="keyword">val</span> record : <span><span><span>(<a href="#type-qualifier">qualifier</a> * <a href="#type-mechanism">mechanism</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-modifier">modifier</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-record">record</a></span></code></div><div class="spec-doc"><p><code>record ms []</code> returns a record which can be serialized into the zone file of a specific domain-name as the sender policy.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_to_string"><a href="#val-record_to_string" class="anchor"></a><code><span><span class="keyword">val</span> record_to_string : <span><a href="#type-record">record</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>record_to_string v</code> returns the serialized version of the record to be able to save it into the zone file of a domain-name as the sender policy.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_of_string"><a href="#val-record_of_string" class="anchor"></a><code><span><span class="keyword">val</span> record_of_string : 
  <span>ctx:<a href="#type-ctx">ctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-record">record</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>record_of_string ~ctx str</code> tries to parse <b>and</b> expand macro of the given string which should come from the TXT record of a domain-name as the sender policy of this domain-name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_equal"><a href="#val-record_equal" class="anchor"></a><code><span><span class="keyword">val</span> record_equal : <span><a href="#type-record">record</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-record">record</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-res"><a href="#type-res" class="anchor"></a><code><span><span class="keyword">type</span> res</span><span> = </span><span>[ </span></code><ol><li id="type-res.None" class="def constructor anchored"><a href="#type-res.None" class="anchor"></a><code><span>| </span></code><code><span>`None</span></code></li><li id="type-res.Neutral" class="def constructor anchored"><a href="#type-res.Neutral" class="anchor"></a><code><span>| </span></code><code><span>`Neutral</span></code></li><li id="type-res.Pass" class="def constructor anchored"><a href="#type-res.Pass" class="anchor"></a><code><span>| </span></code><code><span>`Pass <span class="keyword">of</span> <a href="#type-mechanism">mechanism</a></span></code></li><li id="type-res.Fail" class="def constructor anchored"><a href="#type-res.Fail" class="anchor"></a><code><span>| </span></code><code><span>`Fail</span></code></li><li id="type-res.Softfail" class="def constructor anchored"><a href="#type-res.Softfail" class="anchor"></a><code><span>| </span></code><code><span>`Softfail</span></code></li><li id="type-res.Temperror" class="def constructor anchored"><a href="#type-res.Temperror" class="anchor"></a><code><span>| </span></code><code><span>`Temperror</span></code></li><li id="type-res.Permerror" class="def constructor anchored"><a href="#type-res.Permerror" class="anchor"></a><code><span>| </span></code><code><span>`Permerror</span></code></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="#type-record">record</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_res"><a href="#val-pp_res" class="anchor"></a><code><span><span class="keyword">val</span> pp_res : <span><a href="#type-res">res</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : 
  <span>ctx:<a href="#type-ctx">ctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="Sigs/index.html#type-state">Sigs.state</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'dns</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="keyword">module</span> <a href="Sigs/module-type-DNS/index.html">Sigs.DNS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Sigs/module-type-DNS/index.html#type-backend">backend</a> = <span class="type-var">'t</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Sigs/module-type-DNS/index.html#type-t">t</a> = <span class="type-var">'dns</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<span>[ <a href="#type-res">res</a> <span><span>| `Record</span> of <a href="#type-record">record</a></span> ]</span>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>, <span class="type-var">'t</span>)</span>
    <a href="Sigs/index.html#type-io">Sigs.io</a></span></span></code></div><div class="spec-doc"><p><code>get ~ctx scheduler dns (module DNS)</code> tries to get the sender policy of the domain-name given by <code>ctx</code>. It requires a <code>scheduler</code> which allows the high-kind polymorphism over a monadic scheduler and a DNS implementation to request the sender policy.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : 
  <span>ctx:<a href="#type-ctx">ctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="Sigs/index.html#type-state">Sigs.state</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'dns</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="keyword">module</span> <a href="Sigs/module-type-DNS/index.html">Sigs.DNS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Sigs/module-type-DNS/index.html#type-backend">backend</a> = <span class="type-var">'t</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Sigs/module-type-DNS/index.html#type-t">t</a> = <span class="type-var">'dns</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <a href="#type-res">res</a> <span><span>| `Record</span> of <a href="#type-record">record</a></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-res">res</a>, <span class="type-var">'t</span>)</span> <a href="Sigs/index.html#type-io">Sigs.io</a></span></span></code></div><div class="spec-doc"><p><code>check ~ctx scheduler dns (module DNS)</code> tries to check the sender policy with the given <code>ctx</code>. It returns the result of this check.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-newline"><a href="#type-newline" class="anchor"></a><code><span><span class="keyword">type</span> newline</span><span> = </span></code><ol><li id="type-newline.LF" class="def variant constructor anchored"><a href="#type-newline.LF" class="anchor"></a><code><span>| </span><span><span class="constructor">LF</span></span></code></li><li id="type-newline.CRLF" class="def variant constructor anchored"><a href="#type-newline.CRLF" class="anchor"></a><code><span>| </span><span><span class="constructor">CRLF</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_field"><a href="#val-to_field" class="anchor"></a><code><span><span class="keyword">val</span> to_field : 
  <span>ctx:<a href="#type-ctx">ctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?receiver:<span class="xref-unresolved">Emile</span>.domain <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-res">res</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Mrmime</span>.Field_name.t * <span class="xref-unresolved">Unstrctrd</span>.t</span></code></div><div class="spec-doc"><p><code>to_field ~ctx ?received v</code> serializes as an email field the result of the sender policy check according to the given <code>ctx</code>. The user is able to prepend then its email with this field.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-extracted"><a href="#type-extracted" class="anchor"></a><code><span><span class="keyword">type</span> extracted</span><span> = <span><a href="#type-spf">spf</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-spf"><a href="#type-spf" class="anchor"></a><code><span><span class="keyword">and</span> spf</span><span> = </span><span>{</span></code><ol><li id="type-spf.result" class="def record field anchored"><a href="#type-spf.result" class="anchor"></a><code><span>result : <span>[ `None
         <span>| `Neutral</span>
         <span>| `Pass</span>
         <span>| `Fail</span>
         <span>| `Softfail</span>
         <span>| `Temperror</span>
         <span>| `Permerror</span> ]</span>;</span></code></li><li id="type-spf.receiver" class="def record field anchored"><a href="#type-spf.receiver" class="anchor"></a><code><span>receiver : <span><span class="xref-unresolved">Emile</span>.domain option</span>;</span></code></li><li id="type-spf.sender" class="def record field anchored"><a href="#type-spf.sender" class="anchor"></a><code><span>sender : <span><span class="xref-unresolved">Emile</span>.mailbox option</span>;</span></code></li><li id="type-spf.ip" class="def record field anchored"><a href="#type-spf.ip" class="anchor"></a><code><span>ip : <span><span class="xref-unresolved">Ipaddr</span>.t option</span>;</span></code></li><li id="type-spf.ctx" class="def record field anchored"><a href="#type-spf.ctx" class="anchor"></a><code><span>ctx : <a href="#type-ctx">ctx</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_spf"><a href="#val-pp_spf" class="anchor"></a><code><span><span class="keyword">val</span> pp_spf : <span><a href="#type-spf">spf</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract_received_spf"><a href="#val-extract_received_spf" class="anchor"></a><code><span><span class="keyword">val</span> extract_received_spf : 
  <span>?newline:<a href="#type-newline">newline</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'flow</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="Sigs/index.html#type-state">Sigs.state</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="keyword">module</span> <a href="Sigs/module-type-FLOW/index.html">Sigs.FLOW</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Sigs/module-type-FLOW/index.html#type-backend">backend</a> = <span class="type-var">'t</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Sigs/module-type-FLOW/index.html#type-flow">flow</a> = <span class="type-var">'flow</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<a href="#type-extracted">extracted</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>, <span class="type-var">'t</span>)</span> <a href="Sigs/index.html#type-io">Sigs.io</a></span></span></code></div><div class="spec-doc"><p><code>extract_received_spf ?newline flow scheduler (module Flow)</code> tries to recognized SPF fields values from the given email represented as a <code>flow</code>.</p></div></div><p>/</p><div class="odoc-spec"><div class="spec value anchored" id="val-select_spf1"><a href="#val-select_spf1" class="anchor"></a><code><span><span class="keyword">val</span> select_spf1 : <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(string, <span>[&gt; `None ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-field_received_spf"><a href="#val-field_received_spf" class="anchor"></a><code><span><span class="keyword">val</span> field_received_spf : <span class="xref-unresolved">Mrmime</span>.Field_name.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse_received_spf_field_value"><a href="#val-parse_received_spf_field_value" class="anchor"></a><code><span><span class="keyword">val</span> parse_received_spf_field_value : 
  <span><span class="xref-unresolved">Unstrctrd</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-spf">spf</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div></div></body></html>